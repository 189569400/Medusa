### 漏洞文档 v0.1
#### 1.1 导入包
	0x01 import 导入的包必须要符合python3.6版本
	0x02 导入的包不能是小众的包，以防pip中毒
	0x03 如果不是Python自带的包，并且Medusa里面不存在该包，需要再提交的时候在导入的包后面备注需要的包以及版本号
	例:import XXXX #XXXX=2.0
#### 1.2 URL处理函数
	该函数必须存在，为了对传入的URL进行处理，保证能够提取需要的信息

	def UrlProcessing(url):
		if url.startswith("http"):#判断是否有http头，如果没有就在下面加入
			res = urllib.parse.urlparse(url)
		else:
			res = urllib.parse.urlparse('http://%s' % url)
		return res.scheme, res.hostname, res.port
		
#### 1.3 主函数
##### 0x01 函数名
	每个函数必须以这个为主函数
	Url:传入的网站名
	RandomAgent:随机的Agent
	ProxyIp:代理IP
	def medusa(Url,RandomAgent,ProxyIp):
##### 0x02 对Url进行处理
	获取处理后的scheme和url以及Port,这也是必须存在的
	scheme, url, port = UrlProcessing(Url)
    if port is None and scheme == 'https':
        port = 443
    elif port is None and scheme == 'http':
        port = 80
    else:
        port = port
##### 0x03 Header
	在对header赋值的时候，必须替换里面的User-Agent的值
	替换后为:
	'User-Agent': RandomAgent
##### 0x04 异常处理
	在对利用POC的时候一定要用异常处理函数进行包含，放在一个POC出现异常导致整个函数崩溃
	大致结构:
	try:
	    POC
	 except Exception as e:
	    pass
##### 0x05 判断是否使用代理
	这也是必须存在的
	例:
	if ProxyIp!=None:#判断如果代理IP信息就利用代理IP进行
            proxies = {
                # "http": "http://" + str(ProxyIps) , # 使用代理前面一定要加http://或者https://
                "http": "http://" + str(ProxyIp)
            }
            resp = s.post(payload_url, data=payload, headers=headers, proxies=proxies, timeout=5, verify=False)
	elif ProxyIp==None:#判断如果传入空的代理信息，就使用普通请求
		resp = s.post(payload_url, data=payload,headers=headers, timeout=5, verify=False)
##### 0x06 对结果进行判断
	存在什么漏洞，漏洞对应版本，漏洞的payload等信息都要写清楚，然后用return返回结果
	Medusa = "{} 存在XXX漏洞\r\n漏洞详情:\r\n版本号:XXX\r\nPayload:{}\r\nPost:{}\r\n".format(url, payload_url,payload)
	return (Medusa)
#### 1.4 注意点
	0x01 脚本中不能存在print之类的输出函数
	0x02 使用的函数名必须通俗易懂（如:Payload，PayloadUrl
	0x03 函数名首字母大写，如果有多个单词每个单词首字母都需要大写(如:MedusaScan
	0x04 函数名禁止使用i,a,d,f,c之类的不明意义的字母
	0x05 尽可能多的注释，方便以后对代码的修改
	0x06 无用的注释掉的函数或者代码需要删除
	0x07 该POC必须要能跑通，并且Payload中的Url必须要默认或者通杀的，禁止使用自己命名的目录进行构造POC
	0x08 提交代码需要提交一个能够测试的网站，不然无法验证POC是否能够使用
	0x09 对没有的POC验证需要使用DNSlog
	0x10 禁止在目标中创建或者删除文件（POC如果无回显必须使用DNSlog
#### 1.5 POC模板
	#!/usr/bin/env python
	# _*_ coding: utf-8 _*_

	import urllib
	import requests

	def UrlProcessing(url):
		if url.startswith("http"):#判断是否有http头，如果没有就在下面加入
			res = urllib.parse.urlparse(url)
		else:
			res = urllib.parse.urlparse('http://%s' % url)
		return res.scheme, res.hostname, res.port

	payload=''''''
	def medusa(Url,RandomAgent,ProxyIp):

		scheme, url, port = UrlProcessing(Url)
		if port is None and scheme == 'https':
			port = 443
		elif port is None and scheme == 'http':
			port = 80
		else:
			port = port
		global   resp
		payload_url = scheme+"://"+url+':'+str(port)+'/login.action'
		host=url+':'+str(port)
		headers = {
			'Host':host,
			'Accept-Encoding': 'gzip, deflate',
			'Accept': '*/*',
			'User-Agent': RandomAgent,
			'Content-Type': 'application/x-www-form-urlencoded',
			'DNT': '1',
		}
		try:
			s = requests.session()
			if ProxyIp!=None:
				proxies = {
					# "http": "http://" + str(ProxyIps) , # 使用代理前面一定要加http://或者https://
					"http": "http://" + str(ProxyIp)
				}
				resp = s.post(payload_url, data=payload, headers=headers, proxies=proxies, timeout=5, verify=False)
			elif ProxyIp==None:
				resp = s.post(payload_url, data=payload,headers=headers, timeout=5, verify=False)
			con = resp.text
			code = resp.status_code
			if code==200 and con.lower().find('tomcat')!=-1:
				Medusa = "{} 存在XXX漏洞\r\n漏洞详情:\r\n版本号:XXX\r\nPayload:{}\r\nPost:{}\r\n".format(url, payload_url,payload)
				return (Medusa)
		except Exception as e:
			pass